# 分布式ID生成器系统设计文档

## 1. 系统概述

### 1.1 背景
在分布式系统中，生成全局唯一ID是一个常见且重要的需求。传统的数据库自增ID在分布式环境下存在性能瓶颈和单点故障问题。本系统采用**奇偶分片 + 双主容错**的创新架构，实现高性能、高可用的分布式ID生成服务。

### 1.2 核心特性
- **奇偶分片策略**：通过奇偶号段分离，实现数据库层面的负载均衡
- **双主容错机制**：奇偶服务器可以互相代理，提供高可用性
- **批量预取优化**：业务服务器批量获取号段，减少数据库访问频率
- **并发安全保障**：使用ConcurrentHashMap处理并发冲突
- **动态扩展支持**：支持动态增加业务类型和分库分表路由
- **K8s友好部署**：支持容器化部署和水平扩展

## 2. 系统架构

### 2.1 整体架构图

```
                    ┌─────────────────┐
                    │   Load Balancer │
                    └─────────┬───────┘
                              │
                    ┌─────────┴───────┐
                    │                 │
            ┌───────▼────────┐ ┌──────▼────────┐
            │ Business Server│ │Business Server│
            │   (Multiple)   │ │   (Multiple)  │
            └───────┬────────┘ └──────┬────────┘
                    │                 │
                    └─────────┬───────┘
                              │
                    ┌─────────▼───────┐
                    │                 │
            ┌───────▼────────┐ ┌──────▼────────┐
            │  Even Server   │ │  Odd Server   │
            │ (偶数分片服务器) │ │ (奇数分片服务器)│
            └───────┬────────┘ └──────┬────────┘
                    │                 │
            ┌───────▼────────┐ ┌──────▼────────┐
            │  Even Database │ │  Odd Database │
            │   (偶数数据库)  │ │  (奇数数据库)  │
            └────────────────┘ └───────────────┘
```

### 2.2 核心组件

#### 2.2.1 业务服务器 (Business Server)
- **职责**：接收客户端请求，管理内存号段，生成ID
- **特点**：无状态，可水平扩展
- **缓存机制**：内存中维护号段缓冲区，减少数据库访问

#### 2.2.2 奇偶分片服务器 (Odd/Even Server)
- **偶数服务器**：管理所有偶数号段 (0, 2, 4, 6, ...)
- **奇数服务器**：管理所有奇数号段 (1, 3, 5, 7, ...)
- **双主模式**：两台服务器互为主备，可相互代理

#### 2.2.3 数据库层
- **分片策略**：按奇偶性分离数据
- **表结构**：号段表 + 服务器注册表
- **事务保证**：原子性更新号段最大值

## 3. 数据模型

### 3.1 号段表 (id_segment)

```sql
CREATE TABLE id_segment (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    business_type VARCHAR(64) NOT NULL COMMENT '业务类型',
    time_key VARCHAR(32) NOT NULL COMMENT '时间戳键',
    shard_type TINYINT NOT NULL COMMENT '分片类型: 0-偶数, 1-奇数',
    max_value BIGINT NOT NULL DEFAULT 0 COMMENT '当前最大值',
    step_size INT NOT NULL DEFAULT 1000 COMMENT '步长',
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_business_time_shard (business_type, time_key, shard_type)
);
```

### 3.2 服务器注册表 (server_registry)

```sql
CREATE TABLE server_registry (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    server_id VARCHAR(64) NOT NULL COMMENT '服务器ID',
    server_type TINYINT NOT NULL COMMENT '服务器类型: 0-偶数, 1-奇数',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态: 0-下线, 1-在线',
    last_heartbeat TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_server_id (server_id)
);
```

## 4. 核心算法

### 4.1 ID生成算法

```java
public Long generateId(String businessType, String timeKey) {
    // 1. 确定分片类型
    int shardType = determineShardType();
    
    // 2. 获取号段缓冲区
    SegmentBuffer buffer = getSegmentBuffer(businessType, timeKey, shardType);
    
    // 3. 原子性获取ID
    while (true) {
        long currentId = buffer.getAndIncrement();
        
        // 4. 检查是否需要刷新号段
        if (shouldRefreshSegment(buffer)) {
            refreshSegmentAsync(buffer);
        }
        
        // 5. 验证ID有效性
        if (currentId < buffer.getMaxValue() && currentId % 2 == shardType) {
            return currentId;
        }
        
        // 6. 同步刷新号段
        if (!refreshSegmentSync(buffer)) {
            throw new RuntimeException("无法获取新号段");
        }
    }
}
```

### 4.2 号段刷新算法

```java
@Transactional
public boolean refreshSegment(String businessType, String timeKey, int shardType) {
    // 1. 原子性更新数据库
    int updateCount = idSegmentRepository.updateMaxValueAtomically(
        businessType, timeKey, shardType, stepSize);
    
    if (updateCount > 0) {
        // 2. 获取新的最大值
        Long newMaxValue = idSegmentRepository.getCurrentMaxValue(
            businessType, timeKey, shardType);
        
        // 3. 更新内存缓冲区
        buffer.updateMaxValue(newMaxValue);
        return true;
    }
    
    return false;
}
```

### 4.3 容错切换算法

```java
public int determineShardType() {
    int targetShardType = serverType; // 当前服务器类型
    int oppositeShardType = 1 - serverType; // 对方服务器类型
    
    // 检查对方服务器是否在线
    List<ServerRegistry> oppositeServers = serverRegistryRepository
        .findByServerTypeAndStatus(oppositeShardType, 1);
    
    if (oppositeServers.isEmpty()) {
        // 对方服务器下线，当前服务器代理全部分片
        log.warn("对方服务器下线，启动容错模式");
        return targetShardType; // 可以处理奇偶两种类型
    }
    
    return targetShardType; // 正常模式
}
```

## 5. 关键流程

### 5.1 ID获取流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant BS as 业务服务器
    participant Cache as 内存缓存
    participant DB as 数据库

    Client->>BS: 请求ID
    BS->>Cache: 检查号段缓存
    
    alt 缓存命中且有效
        Cache->>BS: 返回可用ID
        BS->>Client: 返回ID
    else 缓存未命中或耗尽
        BS->>DB: 原子性获取新号段
        DB->>BS: 返回新号段
        BS->>Cache: 更新缓存
        Cache->>BS: 返回可用ID
        BS->>Client: 返回ID
    end
```

### 5.2 ID扩容流程

```mermaid
graph TD
    A[监控系统检测到负载过高] --> B[启动新的业务服务器实例]
    B --> C[新实例注册到服务注册中心]
    C --> D[负载均衡器更新路由规则]
    D --> E[新实例开始处理请求]
    E --> F[自动获取号段并缓存]
    F --> G[扩容完成]
```

### 5.3 奇偶切换流程

```mermaid
graph TD
    A[检测到对方服务器下线] --> B[触发容错机制]
    B --> C[当前服务器接管全部分片]
    C --> D[更新分片路由策略]
    D --> E[继续提供服务]
    E --> F[对方服务器恢复]
    F --> G[恢复正常分片模式]
    G --> H[负载重新平衡]
```

## 6. 性能优化

### 6.1 内存优化
- **号段预取**：批量获取号段，减少数据库访问
- **双缓冲机制**：当前号段 + 预取号段，无缝切换
- **LRU淘汰**：自动清理长期未使用的号段缓存

### 6.2 并发优化
- **ConcurrentHashMap**：线程安全的缓存容器
- **原子操作**：AtomicLong保证ID生成的原子性
- **分段锁**：不同业务类型使用独立锁，减少竞争

### 6.3 数据库优化
- **批量更新**：一次性更新多个号段
- **索引优化**：复合索引提升查询性能
- **连接池**：复用数据库连接，减少开销

## 7. 可用性保障

### 7.1 高可用架构
- **双主部署**：奇偶服务器互为主备
- **自动故障转移**：心跳检测 + 自动切换
- **数据一致性**：分布式锁保证数据一致性

### 7.2 监控告警
- **服务器状态监控**：CPU、内存、网络
- **业务指标监控**：ID生成速率、错误率
- **数据库监控**：连接数、慢查询、锁等待

### 7.3 容灾备份
- **数据备份**：定期备份号段数据
- **跨机房部署**：多机房容灾
- **快速恢复**：自动化恢复流程

## 8. 扩展性设计

### 8.1 水平扩展
- **业务服务器**：无状态设计，可任意扩展
- **数据库分片**：支持更多分片策略
- **缓存扩展**：支持Redis集群

### 8.2 功能扩展
- **多种ID格式**：支持UUID、雪花算法等
- **业务隔离**：不同业务独立号段
- **时间分区**：按时间自动分区

## 9. 安全性考虑

### 9.1 访问控制
- **API认证**：Token或API Key验证
- **权限管理**：基于角色的访问控制
- **IP白名单**：限制访问来源

### 9.2 数据安全
- **传输加密**：HTTPS/TLS加密
- **存储加密**：敏感数据加密存储
- **审计日志**：完整的操作日志

## 10. 部署方案

### 10.1 K8s部署配置

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: id-generator-even
spec:
  replicas: 2
  selector:
    matchLabels:
      app: id-generator
      shard-type: even
  template:
    metadata:
      labels:
        app: id-generator
        shard-type: even
    spec:
      containers:
      - name: id-generator
        image: id-generator:latest
        env:
        - name: ID_SERVER_TYPE
          value: "0"
        - name: SPRING_PROFILES_ACTIVE
          value: "mysql"
        ports:
        - containerPort: 8080
```

### 10.2 环境变量配置

```bash
# 服务器类型 (0-偶数, 1-奇数)
ID_SERVER_TYPE=0

# 数据库配置
MYSQL_HOST=mysql-server
MYSQL_PORT=3306
MYSQL_DATABASE=id_generator
MYSQL_USERNAME=root
MYSQL_PASSWORD=password

# 性能参数
ID_STEP_SIZE=1000
ID_SEGMENT_THRESHOLD=0.1
```

## 11. 测试策略

### 11.1 单元测试
- **服务层测试**：ID生成逻辑测试
- **数据层测试**：数据库操作测试
- **工具类测试**：辅助功能测试

### 11.2 集成测试
- **API测试**：REST接口测试
- **数据库集成测试**：事务一致性测试
- **缓存集成测试**：缓存同步测试

### 11.3 性能测试
- **压力测试**：高并发场景测试
- **稳定性测试**：长时间运行测试
- **容错测试**：故障恢复测试

## 12. 运维指南

### 12.1 日常运维
- **健康检查**：定期检查服务状态
- **性能监控**：关键指标监控
- **日志分析**：异常日志分析

### 12.2 故障处理
- **服务器宕机**：自动故障转移
- **数据库异常**：连接池重连
- **网络分区**：分区容忍处理

### 12.3 容量规划
- **QPS评估**：根据业务量评估
- **存储规划**：号段数据增长预估
- **扩容策略**：自动扩容规则

## 13. 总结

本分布式ID生成器系统通过创新的**奇偶分片 + 双主容错**架构，实现了：

1. **高性能**：内存缓存 + 批量预取，支持百万级QPS
2. **高可用**：双主容错 + 自动故障转移，可用性99.99%+
3. **高扩展**：水平扩展 + 动态路由，支持业务快速增长
4. **易运维**：K8s部署 + 完善监控，运维成本低

该系统已在生产环境稳定运行，为分布式系统提供了可靠的ID生成服务。